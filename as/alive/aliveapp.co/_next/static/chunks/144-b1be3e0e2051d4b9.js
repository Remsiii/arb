"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[144],{9144:function(e,t,s){s.d(t,{eI:function(){return G}});let a=e=>Array.isArray(e)?e:[e],i=(e={},t)=>({...e,filters:[...e.filters||[],...a(t)]}),r=e=>"function"==typeof e?e:()=>e,n=e=>Array.isArray(e)?`[${e.map(n).join(", ")}]`:"string"==typeof e?`"${e}"`:e instanceof Date?`${e.getTime()}`:`${e}`,o=e=>(t,...s)=>{let a=s.map(n).join(", "),i=t&&s.length?", ":"";return`[${e}(${t}${i}${a})]`},l=e=>{let t=o(e);return e=>t(e)},h={at:o("at"),not:o("not"),any:o("any"),in:o("in"),fulltext:o("fulltext"),has:l("has"),missing:l("missing"),similar:(e=>{let t=o(e);return(...e)=>t("",...e)})("similar"),geopointNear:o("geopoint.near"),numberLessThan:o("number.lt"),numberGreaterThan:o("number.gt"),numberInRange:o("number.inRange"),dateAfter:o("date.after"),dateBefore:o("date.before"),dateBetween:o("date.between"),dateDayOfMonth:o("date.day-of-month"),dateDayOfMonthAfter:o("date.day-of-month-after"),dateDayOfMonthBefore:o("date.day-of-month-before"),dateDayOfWeek:o("date.day-of-week"),dateDayOfWeekAfter:o("date.day-of-week-after"),dateDayOfWeekBefore:o("date.day-of-week-before"),dateMonth:o("date.month"),dateMonthAfter:o("date.month-after"),dateMonthBefore:o("date.month-before"),dateYear:o("date.year"),dateHour:o("date.hour"),dateHourAfter:o("date.hour-after"),dateHourBefore:o("date.hour-before")},c=e=>h.at("document.tags",a(e));var u,f,d=Object.defineProperty,g=(e,t,s)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,y=(e,t,s)=>(g(e,"symbol"!=typeof t?t+"":t,s),s);class p extends Error{constructor(e="An invalid API response was returned",t,s){super(e),y(this,"url"),y(this,"response"),this.url=t,this.response=s}}let w=(e,t)=>{let s=e.find(e=>t(e));if(!s)throw new p("Ref could not be found.",void 0,void 0);return s},m=e=>w(e,e=>e.isMasterRef),R=(e,t)=>w(e,e=>e.id===t),b=(e,t)=>w(e,e=>e.label===t),v=e=>e.replace(/%3B/g,";"),k=e=>{let t;let s=e.split("; ");for(let e of s){let s=e.split("="),a=v(s[0]).replace(/%3D/g,"=");if("io.prismic.preview"===a){t=v(s.slice(1).join("="));break}}return t},S=e=>e.replace(/(\n| )*( |{|})(\n| )*/gm,(e,t,s)=>s),T=e=>h.any("document.tags",a(e)),A=e=>h.at("document.type",e);class P extends p{}class j extends p{}class D extends p{}class B extends P{}class q extends P{}class F extends P{}class L extends j{}let I={Any:"Any",Document:"Document",Media:"Media",Web:"Web"},M=e=>{var t;return{link_type:I.Document,id:e.id,uid:e.uid||void 0,type:e.type,tags:e.tags,lang:e.lang,url:null==e.url?void 0:e.url,slug:null==(t=e.slugs)?void 0:t[0],...e.data&&Object.keys(e.data).length>0?{data:e.data}:{}}},$=(e,...t)=>{let s;if(!e)return null;let a="link_type"in e?e:M(e),[i]=t;switch(s="function"==typeof i||null==i?{linkResolver:i}:{...i},a.link_type){case I.Media:case I.Web:return"url"in a?a.url:null;case I.Document:if("id"in a&&s.linkResolver){let e=s.linkResolver(a);if(null!=e)return e}if("url"in a&&a.url)return a.url;return null;case I.Any:default:return null}},O={accessToken:"access_token"},x=e=>"string"==typeof e?e:"desc"===e.direction?`${e.field} desc`:e.field,C=(e,t)=>{let{filters:s,predicates:i,...r}=t,n=new URL("documents/search",`${e}/`);if(s)for(let e of a(s))n.searchParams.append("q",`[${e}]`);if(i)for(let e of a(i))n.searchParams.append("q",`[${e}]`);for(let e in r){let t=O[e]||e,s=r[e];if("orderings"===t){let e=r[t];if(null!=e){let t=a(e).map(e=>x(e)).join(",");s=`[${t}]`}}else"routes"===t&&"object"==typeof r[t]&&(s=JSON.stringify(a(r[t])));null!=s&&n.searchParams.set(t,a(s).join(","))}return n.toString()},_=e=>/^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(e),U=e=>{if(_(e))return`https://${e}.cdn.prismic.io/api/v2`;throw new p(`An invalid Prismic repository name was given: ${e}`,void 0,void 0)},E=e=>{try{return new URL(e),!0}catch{return!1}};var z=Object.defineProperty,J=(e,t,s)=>t in e?z(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,N=(e,t,s)=>(J(e,"symbol"!=typeof t?t+"":t,s),s);(u=f||(f={})).Master="Master",u.ReleaseID="ReleaseID",u.ReleaseLabel="ReleaseLabel",u.Manual="Manual";let G=(e,t)=>new Q(e,t);class Q{constructor(e,t={}){if(N(this,"endpoint"),N(this,"accessToken"),N(this,"routes"),N(this,"brokenRoute"),N(this,"fetchFn"),N(this,"fetchOptions"),N(this,"defaultParams"),N(this,"refState",{mode:f.Master,autoPreviewsEnabled:!0}),N(this,"cachedRepository"),N(this,"cachedRepositoryExpiration",0),N(this,"fetchJobs",{}),E(e)?this.endpoint=e:this.endpoint=U(e),this.accessToken=t.accessToken,this.routes=t.routes,this.brokenRoute=t.brokenRoute,this.fetchOptions=t.fetchOptions,this.defaultParams=t.defaultParams,t.ref&&this.queryContentFromRef(t.ref),"function"==typeof t.fetch)this.fetchFn=t.fetch;else if("function"==typeof globalThis.fetch)this.fetchFn=globalThis.fetch;else throw new p("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.",void 0,void 0);this.fetchFn===globalThis.fetch&&(this.fetchFn=this.fetchFn.bind(globalThis)),this.graphQLFetch=this.graphQLFetch.bind(this)}enableAutoPreviews(){this.refState.autoPreviewsEnabled=!0}enableAutoPreviewsFromReq(e){this.refState.httpRequest=e,this.refState.autoPreviewsEnabled=!0}disableAutoPreviews(){this.refState.autoPreviewsEnabled=!1}async get(e){let t=await this.buildQueryURL(e);return await this.fetch(t,e)}async getFirst(e){var t;let s={...e};e&&e.page||(null==e?void 0:e.pageSize)||(s.pageSize=(null==(t=this.defaultParams)?void 0:t.pageSize)??1);let a=await this.buildQueryURL(s),i=await this.fetch(a,e),r=i.results[0];if(r)return r;throw new j("No documents were returned",a,void 0)}async dangerouslyGetAll(e={}){var t;let s;let{limit:a=1/0,...i}=e,r={...i,pageSize:Math.min(a,i.pageSize||(null==(t=this.defaultParams)?void 0:t.pageSize)||100)},n=[];for(;(!s||s.next_page)&&n.length<a;){let e=s?s.page+1:void 0;s=await this.get({...r,page:e}),n.push(...s.results),s.next_page&&await new Promise(e=>setTimeout(e,500))}return n.slice(0,a)}async getByID(e,t){return await this.getFirst(i(t,h.at("document.id",e)))}async getByIDs(e,t){return await this.get(i(t,h.in("document.id",e)))}async getAllByIDs(e,t){return await this.dangerouslyGetAll(i(t,h.in("document.id",e)))}async getByUID(e,t,s){return await this.getFirst(i(s,[A(e),h.at(`my.${e}.uid`,t)]))}async getByUIDs(e,t,s){return await this.get(i(s,[A(e),h.in(`my.${e}.uid`,t)]))}async getAllByUIDs(e,t,s){return await this.dangerouslyGetAll(i(s,[A(e),h.in(`my.${e}.uid`,t)]))}async getSingle(e,t){return await this.getFirst(i(t,A(e)))}async getByType(e,t){return await this.get(i(t,A(e)))}async getAllByType(e,t){return await this.dangerouslyGetAll(i(t,A(e)))}async getByTag(e,t){return await this.get(i(t,T(e)))}async getAllByTag(e,t){return await this.dangerouslyGetAll(i(t,T(e)))}async getByEveryTag(e,t){return await this.get(i(t,c(e)))}async getAllByEveryTag(e,t){return await this.dangerouslyGetAll(i(t,c(e)))}async getBySomeTags(e,t){return await this.get(i(t,T(e)))}async getAllBySomeTags(e,t){return await this.dangerouslyGetAll(i(t,T(e)))}async getRepository(e){let t=new URL(this.endpoint);return this.accessToken&&t.searchParams.set("access_token",this.accessToken),await this.fetch(t.toString(),e)}async getRefs(e){let t=await this.getRepository(e);return t.refs}async getRefByID(e,t){let s=await this.getRefs(t);return R(s,e)}async getRefByLabel(e,t){let s=await this.getRefs(t);return b(s,e)}async getMasterRef(e){let t=await this.getRefs(e);return m(t)}async getReleases(e){let t=await this.getRefs(e);return t.filter(e=>!e.isMasterRef)}async getReleaseByID(e,t){let s=await this.getReleases(t);return R(s,e)}async getReleaseByLabel(e,t){let s=await this.getReleases(t);return b(s,e)}async getTags(e){try{let t=await this.getCachedRepositoryForm("tags",e),s=new URL(t.action);return this.accessToken&&s.searchParams.set("access_token",this.accessToken),await this.fetch(s.toString(),e)}catch{let t=await this.getRepository(e);return t.tags}}async buildQueryURL({signal:e,fetchOptions:t,...s}={}){let a=s.ref||await this.getResolvedRefString({signal:e,fetchOptions:t}),i=s.integrationFieldsRef||(await this.getCachedRepository({signal:e,fetchOptions:t})).integrationFieldsRef||void 0;return C(this.endpoint,{...this.defaultParams,...s,ref:a,integrationFieldsRef:i,routes:s.routes||this.routes,brokenRoute:s.brokenRoute||this.brokenRoute,accessToken:s.accessToken||this.accessToken})}async resolvePreviewURL(e){var t,s;let a=e.documentID,i=e.previewToken;if(void 0!==globalThis.location){let e=new URLSearchParams(globalThis.location.search);a=a||e.get("documentId"),i=i||e.get("token")}else if(this.refState.httpRequest){if("query"in this.refState.httpRequest)a=a||(null==(t=this.refState.httpRequest.query)?void 0:t.documentId),i=i||(null==(s=this.refState.httpRequest.query)?void 0:s.token);else if("url"in this.refState.httpRequest&&this.refState.httpRequest.url){let e=new URL(this.refState.httpRequest.url,"missing-host://").searchParams;a=a||e.get("documentId"),i=i||e.get("token")}}if(null!=a&&null!=i){let t=await this.getByID(a,{ref:i,lang:"*",signal:e.signal,fetchOptions:e.fetchOptions}),s=$(t,{linkResolver:e.linkResolver});if("string"==typeof s)return s}return e.defaultURL}queryLatestContent(){this.refState.mode=f.Master}queryContentFromReleaseByID(e){this.refState={...this.refState,mode:f.ReleaseID,releaseID:e}}queryContentFromReleaseByLabel(e){this.refState={...this.refState,mode:f.ReleaseLabel,releaseLabel:e}}queryContentFromRef(e){this.refState={...this.refState,mode:f.Manual,ref:e}}async graphQLFetch(e,t){let s=await this.getCachedRepository(),a=await this.getResolvedRefString(),i={"Prismic-ref":a,Authorization:this.accessToken?`Token ${this.accessToken}`:"",...t?t.headers:{}};s.integrationFieldsRef&&(i["Prismic-integration-field-ref"]=s.integrationFieldsRef);let r={};for(let e in i)i[e]&&(r[e.toLowerCase()]=i[e]);let n=new URL(e);n.searchParams.set("ref",a);let o=n.searchParams.get("query");return o&&n.searchParams.set("query",S(o)),await this.fetchFn(n.toString(),{...t,headers:r})}async getCachedRepository(e){return(!this.cachedRepository||Date.now()>=this.cachedRepositoryExpiration)&&(this.cachedRepositoryExpiration=Date.now()+5e3,this.cachedRepository=await this.getRepository(e)),this.cachedRepository}async getCachedRepositoryForm(e,t){let s=await this.getCachedRepository(t),a=s.forms[e];if(!a)throw new p(`Form with name "${e}" could not be found`,void 0,void 0);return a}async getResolvedRefString(e){var t,s;if(this.refState.autoPreviewsEnabled){let e,a;if((null==(t=this.refState.httpRequest)?void 0:t.headers)?"get"in this.refState.httpRequest.headers&&"function"==typeof this.refState.httpRequest.headers.get?a=this.refState.httpRequest.headers.get("cookie"):"cookie"in this.refState.httpRequest.headers&&(a=this.refState.httpRequest.headers.cookie):(null==(s=globalThis.document)?void 0:s.cookie)&&(a=globalThis.document.cookie),a&&(e=k(a)),e)return e}let a=await this.getCachedRepository(e),i=this.refState.mode;if(i===f.ReleaseID)return R(a.refs,this.refState.releaseID).ref;if(i===f.ReleaseLabel)return b(a.refs,this.refState.releaseLabel).ref;if(i===f.Manual){let e=await r(this.refState.ref)();if("string"==typeof e)return e}return m(a.refs).ref}async fetch(e,t={}){var s,a,i,r;let n;let o={...this.fetchOptions,...t.fetchOptions,headers:{...null==(s=this.fetchOptions)?void 0:s.headers,...null==(a=t.fetchOptions)?void 0:a.headers},signal:(null==(i=t.fetchOptions)?void 0:i.signal)||t.signal||(null==(r=this.fetchOptions)?void 0:r.signal)};this.fetchJobs[e]&&this.fetchJobs[e].has(o.signal)?n=this.fetchJobs[e].get(o.signal):(this.fetchJobs[e]=this.fetchJobs[e]||new Map,n=this.fetchFn(e,o).then(async e=>{let t;try{t=await e.json()}catch{}return{status:e.status,headers:e.headers,json:t}}).finally(()=>{this.fetchJobs[e].delete(o.signal),0===this.fetchJobs[e].size&&delete this.fetchJobs[e]}),this.fetchJobs[e].set(o.signal,n));let l=await n;if(404!==l.status&&null==l.json)throw new p(void 0,e,l.json);switch(l.status){case 200:return l.json;case 400:throw new D(l.json.message,e,l.json);case 401:case 403:throw new P(l.json.error||l.json.message,e,l.json);case 404:if(void 0===l.json)throw new L(`Prismic repository not found. Check that "${this.endpoint}" is pointing to the correct repository.`,e,void 0);if("api_notfound_error"===l.json.type)throw new F(l.json.message,e,l.json);if("api_security_error"===l.json.type&&/preview token.*expired/i.test(l.json.message))throw new B(l.json.message,e,l.json);throw new j(l.json.message,e,l.json);case 410:throw new q(l.json.message,e,l.json);case 429:{let s=Number(l.headers.get("retry-after")),a=Number.isNaN(s)?1e3:s;return await new Promise((s,i)=>{setTimeout(async()=>{try{s(await this.fetch(e,t))}catch(e){i(e)}},a)})}}throw new p(void 0,e,l.json)}}}}]);